# my-spring-nginx-app/nginx/nginx.conf
events {
    worker_connections 1024;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    sendfile on;
    keepalive_timeout 65;

    # Define the upstream for your Spring Boot application
    # 'springboot_app' will be the service name in docker-compose.yml
    upstream backend {
        server backend:8080; # Connect to Spring Boot container on its internal port 8080
    }

    server {
        listen 80; # Nginx listens on port 80
        listen [::]:80; # IPv6
	      server_name localhost 127.0.0.1
	# Actual Server
	# server_name yourdomain.com www.yourdomain.com 15.165.18.135; # IMPORTANT: Replace with your actual domain and/or Elastic IP
	# Local Testing

        # Uncomment the following lines after setting up HTTPS with Certbot
        return 301 https://$host$request_uri; # Redirect all HTTP to HTTPS
    }

    server {
        # This server block will be used after Certbot configures HTTPS
        listen 443 ssl; # Nginx listens on port 443 for HTTPS
        listen [::]:443 ssl; # IPv6

	# Actual Server
	# server_name yourdomain.com www.yourdomain.com; # IMPORTANT: Replace with your actual domain
	# Local Testing
	      server_name localhost 127.0.0.1

        # SSL Configuration (Certbot will add these)
        # ssl_certificate /etc/letsencrypt/live/yourdomain.com/fullchain.pem;
        # ssl_certificate_key /etc/letsencrypt/live/yourdomain.com/privkey.pem;
        # include /etc/letsencrypt/options-ssl-nginx.conf;
        # ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

        #localhost ssl Configuration
        ssl_certificate /etc/nginx/certs/localhost.crt;
        ssl_certificate_key /etc/nginx/certs/localhost.key;

        # Recommended SSL Settings for strong security
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers 'TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE';
        ssl_prefer_server_ciphers on;
        ssl_session_cache shared:SSL:10m;
        ssl_session_timeout 1d;
        ssl_session_tickets off;
        ssl_stapling off; # Not applicable for self-signed
        ssl_stapling_verify off; # Not applicable for self-signed
        resolver 8.8.8.8 8.8.4.4 valid=300s; # DNS resolver for OCSP (if stapling was on)
        resolver_timeout 5s;
        location / {
            proxy_pass http://backend; # Proxy to the Spring Boot upstream
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme; # Crucial for Spring Boot to know it's HTTPS

            # Optional: Adjust timeouts
            proxy_connect_timeout 60s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;
        }

        # Optional: Proxy specific paths to the Spring Boot API
        # If your Spring Boot app has APIs under /api/, you can proxy just that
        # location /api/ {
        #     proxy_pass http://springboot_app;
        #     proxy_set_header Host $host;
        #     proxy_set_header X-Real-IP $remote_addr;
        #     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        #     proxy_set_header X-Forwarded-Proto $scheme;
        # }

        # Optional: Serve static files directly from Nginx (e.g., for a separate frontend)
        # If your Spring Boot app also serves static files, you might not need this.
        # location ~* \.(css|js|gif|jpe?g|png)$ {
        #     root /usr/share/nginx/html; # Assumes your static files are mounted here
        #     expires 30d;
        #     add_header Cache-Control "public, no-transform";
        # }

        error_log /var/log/nginx/your-domain.error.log warn;
        access_log /var/log/nginx/your-domain.access.log main;
    }
}
